const passport = require('passport'); // passportJS for authentication
const GoogleStrategy = require('passport-google-oauth20').Strategy; // specific google strategy of oauth2
const mongoose = require('mongoose');
const keys = require('../config/keys');

// one argument means we are trying to fetch something out of mongoose
// two arguments means we are trying to load something into it
const User = mongoose.model('users');

passport.serializeUser((user, done) => { // user here is what was pulled out of the database after the GoogleStrategy callback
    // done callback, used with passport when we have dome some work and want to return smt
    // null (first argument), is an error checker; if there is no error it returns null
    // user.id, is an identifier generated by MongoDB and not by Google
    // -- By using a Mongo generated ID we dont care of the authentication provider of the user (Facebook, Google etc),
    // but instead we have a user record assiged a unique value from Mongo
    done(null, user.id); 
});

// the first argument is the exact token that was stuffed into a cookie - user.id
passport.deserializeUser((id, done) => {
    // quering to all the records and return the one with the credentials
    User.findById(id)
        .then(user => {
            done(null, user); // user that we have just pulled out
        }); 
});

// generic register, passport knows how to authenticate users in general, 
// but it does not know how to authenticate users with Google
// GoogleStrategy, takes 2 parameters, a users id and a users secret, 
// which are provided directly from Google
passport.use(
    new GoogleStrategy( // this strategy has some identifier internally, so everytime 'google' is requested it responds
        {
            clientID: keys.googleClientID,
            clientSecret: keys.googleClientSecret,
            callbackURL: '/auth/google/callback',
            proxy: true // for the callback to return an https, instead of http, we have to tell google that we are okay with the request going through a proxy
        }, 
        async (accessToken, refreshToken, profile, done) => { // callback function
            // findOne - returns the first search record that matches the criteria
            const existingUser = await User.findOne({ googleId: profile.id }) // everytime we reach out to the DB, an asynchronous action is being initiated
            // The query returns a promise, which is a tool that we use in JS for handling async code
            if (existingUser) {
                // we already have a record with the given profile ID
                done(null, existingUser);
                // if we found a user inside a users' collection, this means everything went good
                // -> thus, a 'null' argument is passed                        done(null, existingUser); // 'done' - to tell passport we are all complete
            } else {
                // we dont have a user record with this ID, make a new one
                const user = await new User({ googleId: profile.id }).save() // When we call save, it will take this record (model instance) and save it to the DB
                done(null,user);
           }
        }
    )
);

// logs to test out the callback function in terminal
// console.log('access token', accessToken);
// console.log('refresh token', refreshToken);
// console.log('profile:', profile);